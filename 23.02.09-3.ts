// <타입을 집합으로 생각하자(좁은 타입과 넓은 타입)>

// 타입간에 대입되는 것들과 안 되는 것 살펴보자

// 우리가 이제 타입스크립트를 사용할 때 정확하게 특정타입만 넣는 그런 경우만 생기는 게 아니라, 큰 타입에 작은 타입을 넣으려고 시도할 수도 있고, 작은 타입에 큰  타입을 넣으려고 시도할 수도 있어. 여기서 큰 타입과 작은 타입을 구분할 줄 알아야 되는데,
// type A = string|number
// type B = string;
// 둘 중에 어떤 게 더 넓은 타입일까? A타입이겠지?

// type A = string|number 전체집합 &은 교집합

// 비슷한 원리로 any는 전체집합 never는 공집합으로 볼 수 있다.

// 여기서 룰은 좁은 타입에서 넓은타입으로 대입이 가능하다 반대로는 불가해(넓은타입에서 좁은 타입으로 대입)

// 자 여기서 반대로,
// type C = string & number // 실제로는 없는 타입이지만,
// 얘가 좁을까 type B = string;얘가 더 좁은 타입일까? 당연히 C 타입이 더 좁은 타입이겠지
// 얘네들은 이정도로 간단한데 이제 객체를 한 번 봐야돼 객체가 좀 헷갈림.

// type A = {name: string}
// type B = {age: number}
// 여기서 어떤 게 더 큰건가 이런 걸 잘 파악해야 돼 얘네 둘은 아직 겹치는 건 없기 때문에 뭐 서로 누가 크다 이렇게 말을 할 수는 없다. 근데 이제 type C = {name: string, age: number} type C가 이렇다고 해보자,
// 그럼 셋 중에 누가 더 넓은 타입이고 좁은 타입인지 구분을 할 줄 알아야 해.
// type C = {name: string, age: number} 근데 여러 사람들이 얘가 공간을 많이 차지한다고 얘가 넓은 타입이라고 착각하는 사람들이 있다. 아니다. 얘가 넓은 게 아니라 타입 A,B가 넓은 거다 속성이 적을수록 넓은 타입.
// 객체는 상세할 수록 좁다고 생각하면 돼.
// 타입 A,B보다 넓은 타입을 만들어 보자면,
// type AB = A|B 이런식으로 하면 name 또는 age이기 때문에, 집합관계로 생각해보면 전체집합이기 때문에 넓은타입
// type C도 이렇게 type C = A&B 표현이 가능하다 교집합이기 때문에 좁은타입.

// 실습 해보자면,

// const ab: AB = {name: 'abcde'}; // 또는 이니까 맞게 쓴거지
// const c:C = {name:'kim', age: 29} // 얘도 맞게 씀.

// 이런 상황도 있어.
// const c:C = {name: 'abced', age: 29, married: false}; // 이거 조심해야 됨.
// type C = A&B 얘가 넓을까 const c:C = {name: 'abced', age: 29, married: false};얘가 넓을까? 더 구체적일수록 더 좁은 타입이라 했잖아. 지금 넓은 타입에다가 좁은 타입을 넣었는데, 저 married에 error가 생김. 이건 특수한 상황인데 '객체리터럴 검사'라는 게 생겨서 {name: 'abced', age: 29, married: false} 얘를 C 타입에다 넣으려고 하면 '잉여속성검사'라고 추가적인 검사를 더 하게 돼 타입이 넓냐 좁냐 이 검사뿐만 아니라 잉여속성 검사도 하기 때문에, 에러가 생김. 이런 거는 재미있게도 중간에 하나 데이터를 빼주면,
// const ab: AB = {name:'abcde'}
// const obj = {name:'abcde', age: 29, married: false};
// const c:C = obj;
// 이런식으로 중간에 obj처럼 변수로 빼주기만 해도 바로 에러가 사라져버림

// 여기서 추가로 알아두면 좋은 게 좁은타입 넓은타입 검사할 때 이렇게 '잉여속성검사'라는 게 등장해서 좁은타입 넓은타입 서로간에 대입이 가능한 가 이런 거 해보고 있을 때 객체리터럴로 바로 위처럼 넣어버리면 잉여속성 검사가 등장하기 때문에 괜히 이것 때문에 헷갈리 수가 있음 분명히 좁은타입을 넓은타입에 대입 했는데 어? 왜 안 되지 착각하는 경우가 생길 수 있음.
// 이거는 잉여속성검사라는 새로운 특성이 생겨서 안 되는 거다 이거는 좁은타입 넓은타입과 다른 케이스라고 알아두면 됨.
